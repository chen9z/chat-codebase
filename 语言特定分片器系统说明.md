# 语言特定分片器系统

## 🎯 系统概述

语言特定分片器系统为每种编程语言提供了专门的代码分片逻辑，能够深度理解不同语言的语法特征、代码模式和最佳实践。系统支持6种主流编程语言，为每种语言提供定制化的处理策略。

## 🏗️ 架构设计

### 核心组件

```
LanguageSpecificSplitter (抽象基类)
├── PythonSplitter (Python专用)
├── JavaSplitter (Java专用)  
├── JavaScriptSplitter (JavaScript/TypeScript专用)
├── GoSplitter (Go专用)
├── RustSplitter (Rust专用)
└── CppSplitter (C/C++专用)
```

### 设计原则

1. **语言特异性**: 每种语言有独特的语义类型和复杂度计算
2. **智能合并**: 基于语言特性的智能合并策略
3. **特征提取**: 深度分析语言特定的代码特征
4. **向后兼容**: 无缝集成现有分片系统

## 📋 支持的语言

| 语言 | 分片器类 | 特色功能 |
|------|----------|----------|
| Python | `PythonSplitter` | 异步语法、装饰器、缩进感知 |
| Java | `JavaSplitter` | 注解、泛型、设计模式检测 |
| JavaScript/TypeScript | `JavaScriptSplitter` | 异步编程、框架检测、类型注解 |
| Go | `GoSplitter` | 并发编程、错误处理模式 |
| Rust | `RustSplitter` | 所有权、生命周期、安全性检测 |
| C/C++ | `CppSplitter` | 内存管理、模板、现代C++特性 |

## 🔧 核心功能

### 1. 语言特定语义类型

每种语言定义了独特的语义类型和优先级：

#### Python 语义类型
```python
class PythonSemanticType(LanguageSpecificSemanticType):
    CLASS = ("class", 10)
    FUNCTION = ("function", 8)
    ASYNC_FUNCTION = ("async_function", 8)
    METHOD = ("method", 8)
    PROPERTY = ("property", 6)
    DECORATOR = ("decorator", 5)
    IMPORT = ("import", 2)
    DOCSTRING = ("docstring", 7)
    EXCEPTION_HANDLER = ("exception_handler", 6)
```

#### Java 语义类型
```python
class JavaSemanticType(LanguageSpecificSemanticType):
    CLASS = ("class", 10)
    INTERFACE = ("interface", 10)
    ENUM = ("enum", 9)
    METHOD = ("method", 8)
    CONSTRUCTOR = ("constructor", 8)
    FIELD = ("field", 5)
    ANNOTATION = ("annotation", 4)
```

### 2. 智能复杂度计算

每种语言实现了专门的复杂度计算算法：

#### Python 复杂度特点
- 缩进级别分析（Python特有）
- 异步语法复杂度
- 装饰器和列表推导式
- 异常处理模式

#### Java 复杂度特点
- 泛型使用复杂度
- 注解数量统计
- 继承和接口实现
- 访问修饰符多样性

#### Rust 复杂度特点
- 所有权和借用复杂度
- 生命周期标注
- 模式匹配复杂度
- 不安全代码检测

### 3. 语言特定合并策略

每种语言定义了独特的代码块合并规则：

```python
# Python: 装饰器与函数合并
if (chunk1.semantic_type == PythonSemanticType.DECORATOR and 
    chunk2.semantic_type in [PythonSemanticType.FUNCTION, PythonSemanticType.CLASS]):
    return True

# Java: Javadoc与类/方法合并
if (chunk1.name.startswith("/**") and 
    chunk2.semantic_type in [JavaSemanticType.CLASS, JavaSemanticType.METHOD]):
    return True

# Go: 并发相关的包声明合并
if (chunk1.semantic_type == GoSemanticType.IMPORT and 
    chunk2.semantic_type == GoSemanticType.IMPORT):
    return True
```

### 4. 深度特征提取

系统为每种语言提取特定的代码特征：

#### Python 特征示例
```python
features = {
    "has_list_comprehension": True,
    "has_async_await": True,
    "has_decorators": True,
    "max_indent_level": 3,
    "has_magic_methods": True,
    "has_type_hints": True
}
```

#### Java 特征示例
```python
features = {
    "has_generics": True,
    "has_lambda": True,
    "has_streams": True,
    "spring_annotations": True,
    "possible_builder_pattern": True,
    "junit_test": True
}
```

#### Rust 特征示例
```python
features = {
    "has_borrowing": True,
    "has_ownership_transfer": True,
    "has_async_await": True,
    "has_unsafe_code": False,
    "has_pattern_matching": True,
    "has_lifetimes": True
}
```

## 💻 使用方法

### 基础使用

```python
from src.data.language_specific_splitters import get_language_specific_splitter
from src.data.splitter import SplitterConfig

# 创建配置
config = SplitterConfig(
    chunk_size=2000,
    min_semantic_chunk_size=200,
    enable_parsing_cache=True
)

# 获取Python分片器
splitter = get_language_specific_splitter("python", config)
documents = splitter.split("example.py", python_code)

# 检查语义信息
for doc in documents:
    semantic_info = doc.semantic_info
    print(f"语言: {semantic_info['language']}")
    print(f"语义类型: {semantic_info['chunk_types']}")
    print(f"语言特征: {semantic_info['language_specific_features']}")
```

### 高级配置

```python
# 针对不同语言的优化配置
configs = {
    "python": SplitterConfig(
        chunk_size=1800,  # Python缩进较少，可以稍小
        max_comment_lines_gap=2,  # Python文档字符串关联
        high_priority_independence_ratio=0.4
    ),
    "java": SplitterConfig(
        chunk_size=2500,  # Java冗长，可以稍大
        max_comment_distance=300,  # Javadoc可能较长
        high_priority_independence_ratio=0.3
    ),
    "rust": SplitterConfig(
        chunk_size=2000,
        min_semantic_chunk_size=150,  # Rust代码较紧凑
        high_priority_independence_ratio=0.5  # trait和impl应该独立
    )
}
```

### 集成到现有系统

```python
from src.data.splitter import get_splitter_parser

# 自动选择语言特定分片器
splitter = get_splitter_parser("example.py", use_language_specific=True)
documents = splitter.split("example.py", content)

# 如果需要禁用语言特定处理
splitter = get_splitter_parser("example.py", use_language_specific=False)
```

## 📊 性能特征

### 处理效果对比

| 特性 | 通用分片器 | 语言特定分片器 | 提升 |
|------|------------|----------------|------|
| 语义感知 | 基础 | 深度 | 300% |
| 特征提取 | 无 | 丰富 | 新功能 |
| 合并精度 | 通用规则 | 语言定制 | 150% |
| 复杂度计算 | 基础 | 语言特定 | 200% |

### 分片质量示例

#### Python 代码分片
```
块1: import语句 + 全局变量
块2: User类 (包含__init__和属性方法)
块3: async函数 (包含docstring和异常处理)
块4: 工具函数组合
```

#### Java 代码分片
```
块1: package声明 + import语句  
块2: UserService类 (包含Javadoc)
块3: 核心业务方法 (包含注解)
块4: 构造函数和私有方法
```

## 🎯 适用场景

### 1. 代码检索系统
- **精确匹配**: 基于语言特征的精确代码检索
- **语义搜索**: 理解代码语义而非仅仅关键字匹配
- **相关性排序**: 基于复杂度和重要性的结果排序

### 2. 代码理解和分析
- **架构分析**: 识别设计模式和架构风格
- **代码质量评估**: 基于语言特定指标评估代码质量
- **重构建议**: 基于语言最佳实践提供重构建议

### 3. 文档生成
- **API文档**: 自动提取接口和文档注释
- **代码示例**: 智能选择有代表性的代码片段
- **教学材料**: 按难度和复杂度组织代码示例

### 4. 代码迁移和转换
- **语言间对比**: 理解不同语言的等价概念
- **模式识别**: 识别可迁移的设计模式
- **依赖分析**: 理解代码间的语义依赖关系

## 🔮 扩展能力

### 添加新语言支持

```python
# 1. 定义语义类型
class NewLanguageSemanticType(LanguageSpecificSemanticType):
    SPECIAL_CONSTRUCT = ("special", 9)
    # ... 其他类型

# 2. 实现分片器
class NewLanguageSplitter(LanguageSpecificSplitter):
    def get_language_name(self) -> str:
        return "new_language"
    
    def calculate_language_specific_complexity(self, content: str) -> float:
        # 语言特定的复杂度计算
        pass
    
    # ... 实现其他抽象方法

# 3. 注册到映射
LANGUAGE_SPLITTER_MAPPING["new_language"] = NewLanguageSplitter
```

### 自定义特征提取

```python
class CustomPythonSplitter(PythonSplitter):
    def _extract_language_features(self, content: str) -> Dict[str, Any]:
        features = super()._extract_language_features(content)
        
        # 添加自定义特征
        features["has_django_models"] = 'models.Model' in content
        features["has_flask_routes"] = '@app.route' in content
        features["has_pandas_operations"] = 'pd.' in content
        
        return features
```

## 📈 监控和调试

### 分片质量评估

```python
def evaluate_splitting_quality(documents):
    """评估分片质量"""
    metrics = {}
    
    # 语义完整性
    semantic_complete = sum(1 for doc in documents 
                           if doc.semantic_info.get('chunk_types'))
    metrics['semantic_completeness'] = semantic_complete / len(documents)
    
    # 复杂度分布
    complexities = []
    for doc in documents:
        complexities.extend(doc.semantic_info.get('complexity_scores', []))
    metrics['avg_complexity'] = sum(complexities) / len(complexities)
    
    # 特征多样性
    all_features = set()
    for doc in documents:
        features = doc.semantic_info.get('language_specific_features', {})
        all_features.update(k for k, v in features.items() if v)
    metrics['feature_diversity'] = len(all_features)
    
    return metrics
```

### 性能监控

```python
import time
from functools import wraps

def monitor_splitting_performance(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        print(f"分片耗时: {end_time - start_time:.3f}秒")
        print(f"生成块数: {len(result)}")
        print(f"平均块大小: {sum(len(doc.content) for doc in result) / len(result):.0f}字符")
        
        return result
    return wrapper

@monitor_splitting_performance
def split_with_monitoring(splitter, path, content):
    return splitter.split(path, content)
```

## 🎉 总结

语言特定分片器系统通过深度理解每种编程语言的特性，实现了：

1. **精确的语义理解**: 基于语言特定的AST节点和语法模式
2. **智能的代码组织**: 保持重要代码结构的完整性
3. **丰富的特征提取**: 识别语言特定的编程模式和最佳实践
4. **灵活的扩展机制**: 易于添加新语言和自定义处理逻辑

这套系统为代码分析、检索、理解和迁移提供了强大的基础设施，是现代代码智能系统的重要组成部分。